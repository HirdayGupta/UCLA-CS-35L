Exercise 1.1
2. C-s H T M L Enter
3. C-s s c a v e n g e r Enter M-b
4. C-s s e l f - r e f e r e n t i a l Enter M-b M-b
5. C-s a r r o w Enter M-b
6. C-e
7. C-a
8. [non-keystrok answer]: Yes. Using emacs using keybindings.
10: C-x C-c

Exercise 1.2
2. M-g M-g 18 C-k C-k
3. C-s D E Enter C-a  C-k C-k
4. C-s w i k Enter C-s w i k i p Enter C-a C-p C-u 4 C-k
5. C-s < ! Enter Backspace Backspace C-u 5 C-d C-s < ! Enter C-a C-u 4 C-k C-s < ! Enter C-a C-k

Exercise 1.3
2. C-s A s s i g n m e n t 1 M-% A s s i g n m e n t 51 Enter y y
3. C-s U T F - 8 M-% U S - A S C I I Enter y
4. C-s < / o l > Enter Enter

Exercise 1.4
3. M-> C-r < ! Enter C-SP C-e M-w M-g M-g 370 C-y Enter
4. M-> C-r < ! C-r Enter C-SP C-e C-u 3 C-n M-w M-g M-g 356 C-y Enter M->
   C-r < ! C-r C-r Enter C-SP C-u 7 C-f M-w M-g M-g 355 C-e C-u 4 C-p C-y M->
   C-r < ! C-r C-r C-r Enter C-SP C-e C-n C-n M-w M-g M-g 322 C-y Enter Enter
   M-> C-r < ! C-u C-r C-r C-r C-r Enter C-SP C-e M-w M-g M-g 113 C-y Enter M->
   C-r < ! C-r C-r C-r C-r C-r Enter C-SP C-e M-w M-g M-g 18 C-y Enter
5. M-> C-r - - - C-r C-r Enter C-SP M-> C-w 
6. C-x u
7. - - > C-r - - - C-r C-r Enter < - - Enter
8. C-s < o l > M-% y y y y y y y (Non-keystroke answer: found and replaced 7 instances)

Exercise 1.5
1. C-x d Enter + j u n k Enter
2. C-x d j u n k Enter C-x C-f h e l l o . c
3. M-x c o m p i l e Enter g c c h e l l o . c - o h e l l o Enter
4. C-x b h e l l o - o u t Enter C-u M-! . / h e l l o Enter
5. C-SP M-> M-w C-x C-f k e y 1 . t x t M-> C-y
#include <stdio.h>
int
main (void)
{
  char n = '\n';
  char b = '\\';
  char q = '"';
  char const *p = "#include <stdio.h>%cint%cmain (void)%c{%c  char n = '%cn';%c  char b = '%c%c';%c  char q = '%c';%c  char const *p = %c%s%c;%c  printf (p, n, n, n, n, b, n, b, b, n, q, n, q, p, q, n, n, n, n);%c  return 0;%c}%c";
  printf (p, n, n, n, n, b, n, b, b, n, q, n, q, p, q, n, n, n, n);
  return 0;
}

Exercise 1.6
1. C-x b Enter (Scratch is the default buffer)
2. ( r a n d o m ) C-j
3. ( s e t q  x  ( r a n d o m ) ) C-j ( s e t q  y  ( r a n d o m ) ) C-j
4. ( -  x  y  ) C-j (Non-keystroke answer: The answer is not mathematically
   corrrect).
5. M-: ( - x y ) Enter (Non-keystroke answer: M-: returns three answers, the
   integer answer (same as above), a hexadecimal answer and an octal answer)
6. (Non-keystroke answer: The two numbers are not truly random. As stated
   in the EMACS Lisp documentation for 'random'  They are
   pseudo-random numbers generated by a deterministic computer program
   but they have certain properties that mimic a random series.)
7. Let the size of an integer on the given machine be n bits.
   Given that random generates a number that is upto n bits large.
   We notice that the answer was incorrect because of 'bit overflow'
   - A phenomenon where the answer is too large to be stored by an int.
   Now, we will calculate the probability of the answer being incorrect.
   Notice that for the difference to overflow, (- x y) must not fall in the
   range [-2^(n-1), 2^(n-1) - 1].
   Now, let x = k (a perfectly randomly generated number).
   For overflow to occur,
       	 k - y must not fall in the range [-2^n-1, 2^n-1 - 1].
   Therefore,
	k - y < -2^(n-1) OR k - y > 2^(n-1) -1
   Hence,
	-2^(n-1) + k + 1 < y < 2^(n-1) + k

   For a perfectly randomly generated y, the probablity that an overflow will
   occur is simply the entire above range (which will result in overflow)
   divided by the total allowed range (of possible integer values)

	
    

   
    

